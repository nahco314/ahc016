import copy
import random

from ahc016.main import Graph

g = Graph.from_01(
    100,
    "110000001100011111110101011111000110110011000000100000000001000011001010111001010010010100000110111001001000000110101011001000100010011010011001111000000001000011110110001001000000101110010101100010001100101101100101000000111000100011011001001100011111001111101011000100111001110110011101111110010011001000111011101001011011011110101011001100001101110011010100010000000110110100011101111000010101010100110100110110110000101111111110011111110111101100011011001101001001011111010001111100100000100101000100110101110001000110001110000001010010000001101010101000010000000001001100010101001110001111000010111100011110000111000010110011100101010100011011101111110100001010111101001101011110111010011111010100110111101011010101100100001101111110111110110011101110000111101111100010000110001011000010110111110010100111101000101111001011101100001011001011100011101011100100100000001111110100111000110100110110111000111101101001110010001111001000100001110111011110110110001010101000100010101000101110111111111110101101001110010100000110100011000100110000100110000011000101011110100001100100000010001001001000001101010110010010100101111101111001001111111010110011100100110111011101101111010001101101000110011001110000011011011100000011110110000110100010010111010000111001111001010101110110110010111011110101101001111111110000001111011000110000100010011110010011100110010010000010100000000000011111011111011111110100101000101110110110100100111100010010111001101110101110111110011110001101001010101101110110110111101001011111110001011100010110101100110001110111101000100001001110001100100001101101110100100001010010111010010010111101111110100001000010010011010001001000011000011011011000000111110010001110110011110010101100110011111111100101111011110111101011110100011100011100010101100111100001001111011100001010100100010111111011111111100010110111010011010111100100100001110010110101100111111000101101011011110111111100110101101000101101001010101101000100100100001100100000100010101111010000100010000010100101100001101001100011001011010111001101100100110011000110100001000000010101000011000011100001100000000010110011101001110111000101111011001011010101100110111011101010100110101011100111111011100101110111111101011111000100110110001111101110001100111001101010001001101101000100010000000011010111000010100000010100011001110010110100100001001000010000101000100011110011010110000011100000000100011101110111001111101100010010011010100111001111100110110000101011010000111001000100010010011001011011101110100000011111011101111001001110101110000010010110100001101100000100010110011110110111010110111111111110111101111111111011110110110110100111111000101111100101100010110011000101001110100011011010111010000011011010110000111110100111111101101101010010001000101001110101000011100010111111111000010100011010110111101111100001111111100010110100110001010110110101000101000011100011001000100001110011100001011100100111110010000001110100111101010100000111001010100010000100001000100111000001111010110111101100011001111000000000011000000001001101010000111101110011111000001001010010100011011110110011100010111001110000001111100100000100110101101000110101101101011101111010110100110101111001110100100101011111011100111111110110100100111010111001110000101000011110110100100011110000001000110010010000000000111101010011100100100010110011010001011110011110000001011101010001111101011001111100000000010100000010010101100101000010000001010001111101110111101110101010010100001110110000000010010110100101010000000000101100110011000000010001100000000000100111001010111010000001000000101101100000110000100011101101001110101100000101000100100010100100000100010010110100011110111010000101010010011101001001100101101101100100111110000001001011110000111100111010111110111100111110011001111101001000001100010101000110011001000100101001011010100110000000100000101011110111111110010101100010000100011001111111000000111110101111000111111100110101111010010010000111010111001000101101111111000110011100110101010101110101010001001101101101100011101110111110100010001101101111000101011011110001010101000010110101101011100000101111100101110010110001001011101101100101011011001010000010001100001010100011110100000000100111000010000000000100100100100111111001001110110011010111110111011010111111011111000100011100000111010100011000111010011000111000101011000110101110011100101001000010010100111101010011111110111111111110010011101101000111111101011111111010101100000100111101101011001111000100100111011010101110111101111101100110011010111000010101110000000101100100010100100010100101111101000101111010110000000000011001001001010001001111001000010100011011101001101011010101110001110010000001011000100110010101100100010010111010100101011111100110100101110110101100110011101110000110100110111100100111110011110010101110000000010100101101100010111101010011001100100101011100010110010001101001000100001101000110001101010100001101111111000010110010100000101100101111011111101011000010000011001100010000",
)


# maximum k-plex problem


def vertex_reduction(g: Graph, lb: int, k: int):
    q = []
    for v in range(g.n):
        if g.degrees[v] + k <= lb:
            q.append(v)
    while q:
        v = q.pop()
        for u in g.adj(v):
            if g.degrees[u] + k - 1 <= lb:
                q.append(u)
        for u in g.adj(v):
            g.disconnect(u, v)

    return g


def r(g: Graph, k, s: list[int], u: int) -> int:
    return k - len(set(s) - (set(g.adj(u)) | {u})) - 1


def c(g: Graph, k: int, s: list[int], u: int, v: int) -> int:
    v_dash = (set(g.adj(v)) - set(s)) | {v}
    d_g_dash_u = len(set(g.adj(u)) & v_dash)
    return min(d_g_dash_u + r(g, k, s, u) + 1, len(v_dash)) + r(g, k, s, v)


def v_reduction(g: Graph, s: list[int], lb: int, k: int, v: int):
    q = []
    for u in set(g.adj(v)) - set(s):
        if c(g, k, s, u, v) <= lb - len(s) + 1:
            q.append(u)
    while q:
        u = q.pop()
        h = (set(g.adj(u)) - set(g.adj(v))) - set(s)
        if g.degrees[u] >= 0:
            for i in g.adj(u):
                g.disconnect(i, u)
        for w in h:
            if c(g, k, s, w, v) <= lb - len(s) + 1:
                q.append(w)

    return g


def k_reduction(g: Graph, k: int, s: list[int]):
    for u in s:
        if not (len(set(s) - set(g.adj(u))) + 1 == k):
            continue
        for v in set(range(g.n)) - (set(g.adj(u)) | set(s)):
            for i in g.adj(v):
                g.disconnect(i, v)
    for u in set(range(g.n)) - set(s):
        if not (len(set(s) - set(g.adj(u))) + 1 > k):
            continue
        for i in g.adj(u):
            g.disconnect(i, u)

    return g


def bb(g: Graph, k: int, s: list[int], lb: int) -> int:
    if set(range(g.n)) - set(s) == set():
        return len(s)
    v = random.choice(list(set(range(g.n)) - set(s)))
    s.append(v)
    gr = copy.deepcopy(g)
    g = k_reduction(g, k, s)
    g = vertex_reduction(g, lb, k)
    g = v_reduction(g, s, lb, k, v)

    if (
        len(list(u for u in set(range(g.n)) - set(s) if g.degrees[u] + k > lb)) + len(s)
        > lb
    ):
        lb = max(lb, bb(g, k, s, lb))
    lb = max(lb, remove_reduction(gr, s, lb, k))
    return lb
